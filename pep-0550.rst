PEP: 550
Title: Execution Contexts
Version: $Revision$
Last-Modified: $Date$
Author: Yury Selivanov <yury@magic.io>
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 27-Jul-2017
Python-Version: 3.7
Post-History:


Abstract
========

This PEP proposes a new mechanism to manage execution state--the
logical environment in which a function, a thread, a generator,
or a coroutine executes in.

A few examples of where having a reliable state storage is required:

 * Decimal contexts and ``numpy.errstate``;

 * Context managers like ``warnings.catch_warnings``;

 * Storing request-related data such as security tokens and request
   data in web applications;

 * Profiling, collecting tracing data, and logging in complex and
   large code bases.

The usual solution for storing state is to use a Thread-local Storage
(TLS), implemented in the standard library as ``threading.local()``.
Unfortunately, TLS does not work for isolating state of generators or
asynchronous code because such code shares a single thread.


Rationale
=========

Traditionally a Thread-local Storage (TLS) is used for storing the
state.  However, the major flaw of using the TLS is that it works only
for multi-threaded code.  It is not possible to reliably contain the
state within a generator or a coroutine.  For example, consider
the following generator::

    def calculate(precision, ...):
        with decimal.localcontext() as ctx:
            # Set the precision for decimal calculations
            # inside this block
            ctx.prec = precision

            yield calculate_something()
            yield calculate_something_else()

Decimal context is using a TLS to store the state, and because TLS is
not aware of generators, the state can leak.  The above code will
not work correctly, if a user iterates over the ``calculate()``
generator with different precision in parallel::

    g1 = calculate(100)
    g2 = calculate(50)

    items = zip(g1, g2)

    # items[0] will be a tuple of:
    #   first value from g1 calculated with 100 precision,
    #   first value from g2 calculated with 50 precision.
    #
    # items[1] will be a tuple of:
    #   second value from g1 calculated with 50 precision,
    #   second value from g2 calculated with 50 precision.

Inability to use TLS for asynchronous code has lead to proliferation
of ad-hoc solutions, limited to be supported only by code that was
explicitly enabled to work with them.

The current status quo is that any library that uses a TLS, will
likely not work as expected in asynchronous code or with generators
(see [3]_ as an example.)

Some languages that have coroutines or generators recommend to
manually pass a ``context`` object to every function, see [1]_
describing the pattern for Go.  This approach, however, has limited
use for Python, where we have a huge ecosystem that was built to work
with a TLS-like context.  Moreover, passing the context explicitly
does not work at all for libraries like ``decimal`` or ``numpy``,
which use operator overloading.

.NET runtime, which has support for async/await, has a generic
solution of this problem, called ``ExecutionContext`` (see [2]_).
On the surface, working with it is very similar to working with a TLS,
but the former explicitly supports asynchronous code.  The .NET
solution directly inspired this PEP.


Goals
=====

An acceptable solution for Python should meet the following
requirements:

 * Transparent support for code executing in threads, coroutines,
   and generators with an easy to use API.

 * No negative impact on the performance of the existing code or the
   code that will be using the new mechanism.

 * Fast C API for packages like ``decimal`` and ``numpy``.

 * The cost of accessing the context should be similar to that of
   accessing TLS.

 * Should work for compilers like Cython.

The ultimate goal of this PEP is make it possible to update
a context manager like the below::

    _local = threading.local()

    @contextmanager
    def context(x):
        old_x = _local.x
        _local.x = x
        try:
            yield
        finally:
            _local.x = old_x

to a more robust version that can be reliably used in generators
and async/await code, with a simple transformation::

    @contextmanager
    def context(x):
        old_x = get_context_value('x')
        set_context_value('x', x)
        try:
            yield
        finally:
            set_context_value('x', old_x)


Specification
=============

This proposal introduces a new object ``sys.ExecutionContext`` (EC)
along with a Python API and a C API to interact with it.  CPython
will be modified to correctly maintain execution contexts for
threads, async/await code, and generators.

On the high-level, the execution context API is defined as follows:

1. A new object called ``sys.ExecutionContext`` (EC).  EC objects
   are immutable collections of key/value data.

2. EC is a snapshot of a program context at some point.  We store the
   current EC object in the global TLS (``PyThreadState``
   for CPython.)

3. A set of APIs to work with EC:

   * ``sys.new_execution_context()``: create a new EC object and
     return it to the caller.

   * ``sys.get_execution_context()``: get the EC from the global TLS,
     i.e. return the current EC object for the caller.

   * ``sys.set_execution_context(ec)``: set the passed EC object to
     the global TLS.

   * ``sys.set_execution_context_value(key, value)``: get the current
     EC for the caller, add the passed key/value to it, set the new
     EC object.  In pseudo-code::

         current = sys.get_execution_context()
         new = current.set(key, value)
         sys.set_execution_context(new)

   * ``sys.get_execution_context_value(key)``: get the current
     EC object and lookup the ``key`` key on it::

         current = sys.get_execution_context()
         return current.get(key)

An important consequence is that any code that is using the above API,
is thread-safe by design.  The rest of the PEP is focused on defining
the semantics for generators and coroutines within the same thread.

First, let's implement a basic context manager encapsulating some
state using the new APIs.  We will use it in all code examples in
this PEP::

    class Foo:
        def __init__(self, foo):
            self.foo = foo

        def __enter__(self):
            self.old_foo = sys.get_execution_context_value('foo')
            sys.set_execution_context_value('foo', self.foo)

        def __exit__(self, *exc):
            sys.set_execution_context_value('foo', self.old_foo)

    def get_foo():
        return sys.get_execution_context_value('foo')


Regular Code
------------

Regular code will just work with the already defined EC semantics::

    with Foo('spam'):
        assert get_foo() == 'spam'

        with Foo('ham'):
            assert get_foo() == 'ham'

        assert get_foo() == 'spam'


Generators
----------


Coroutines
----------


References
==========

.. [1] https://blog.golang.org/context

.. [2] https://msdn.microsoft.com/en-us/library/system.threading.executioncontext.aspx

.. [3] https://github.com/numpy/numpy/issues/9444

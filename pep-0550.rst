PEP: 550
Title: Execution Contexts
Version: $Revision$
Last-Modified: $Date$
Author: Yury Selivanov <yury@magic.io>
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 27-Jul-2017
Python-Version: 3.7
Post-History:


Abstract
========

This PEP proposes a new mechanism to manage execution state--the
logical environment in which a function, a thread, a generator,
or a coroutine executes in.

A few examples of where having a reliable state storage is required:

 * Context managers like decimal contexts,``numpy.errstate``,
   and ``warnings.catch_warnings``;

 * Storing request-related data such as security tokens and request
   data in web applications;

 * Profiling, tracing, and logging in complex and large code bases.

The usual solution for storing state is to use a Thread-local Storage
(TLS), implemented in the standard library as ``threading.local()``.
Unfortunately, TLS does not work for isolating state of generators or
asynchronous code because such code shares a single thread.


Rationale
=========

Traditionally a Thread-local Storage (TLS) is used for storing the
state.  However, the major flaw of using the TLS is that it works only
for multi-threaded code.  It is not possible to reliably contain the
state within a generator or a coroutine.  For example, consider
the following generator::

    def calculate(precision, ...):
        with decimal.localcontext() as ctx:
            # Set the precision for decimal calculations
            # inside this block
            ctx.prec = precision

            yield calculate_something()
            yield calculate_something_else()

Decimal context is using a TLS to store the state, and because TLS is
not aware of generators, the state can leak.  The above code will
not work correctly, if a user iterates over the ``calculate()``
generator with different precision in parallel::

    g1 = calculate(100)
    g2 = calculate(50)

    items = list(zip(g1, g2))

    # items[0] will be a tuple of:
    #   first value from g1 calculated with 100 precision,
    #   first value from g2 calculated with 50 precision.
    #
    # items[1] will be a tuple of:
    #   second value from g1 calculated with 50 precision,
    #   second value from g2 calculated with 50 precision.

Another terrifying example is using ``warnings.catch_warnings``
in a coroutine::

    async def coro():
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            await something()

    # Awaiting ``coro()`` will randomly silence warnings in
    # unrelated async code executing cooperatively.

Inability to use TLS for asynchronous code has lead to proliferation
of ad-hoc solutions, limited to be supported only by code that was
explicitly enabled to work with them.

The current status quo is that any library, including the standard
library, that uses a TLS, will likely not work as expected in
asynchronous code or with generators (see [3]_ as an example.)

Some languages that have coroutines or generators recommend to
manually pass a ``context`` object to every function, see [1]_
describing the pattern for Go.  This approach, however, has limited
use for Python, where we have a huge ecosystem that was built to work
with a TLS-like context.  Moreover, passing the context explicitly
does not work at all for libraries like ``decimal`` or ``numpy``,
which use operator overloading.

.NET runtime, which has support for async/await, has a generic
solution of this problem, called ``ExecutionContext`` (see [2]_).
On the surface, working with it is very similar to working with a TLS,
but the former explicitly supports asynchronous code.  The .NET
solution directly inspired parts of PEP.


Goals
=====

An acceptable solution for Python should meet the following
requirements:

 * Transparent support for code executing in threads, coroutines,
   and generators with an easy to use API.

 * Negligible impact on the performance of the existing code or the
   code that will be using the new mechanism.

 * Fast C API for packages like ``decimal`` and ``numpy``.

 * The cost of accessing the context should be similar to that of
   accessing TLS.

 * Should work for compilers like Cython.

The ultimate goal of this PEP is make it possible to update
a context manager like the below::

    _local = threading.local()

    @contextmanager
    def context(x):
        old_x = _local.x
        _local.x = x
        try:
            yield
        finally:
            _local.x = old_x

to a more robust version that can be reliably used in generators
and async/await code, with a simple transformation::

    @contextmanager
    def context(x):
        old_x = get_execution_context_value('x')
        set_execution_context_value('x', x)
        try:
            yield
        finally:
            set_execution_context_value('x', old_x)

Keep in mind, that although the PEP features many new APIs and
discusses a lot of implementation details, there will be only two
functions that 99.9% of Python users will ever need to use:

 * ``set_execution_context_value(key, value)``,
 * ``get_execution_context_value(key)``.

In short, the goal of the PEP is to provide a more reliable
alternative to ``threading.local()``.  Explicit is still better than
implicit, hence the new APIs should only be used when passing the
state explicitly is not possible.


Specification
=============

This proposal introduces a new object ``sys.ExecutionContext`` (EC)
along with a Python API and a C API to interact with it.  CPython
will be modified to correctly maintain execution contexts for
threads, async/await code, and generators.

On the high-level, the execution context API is defined as follows:

1. A new dict-like object called ``sys.ExecutionContext`` (EC).

2. EC is a snapshot of a program context at some point.  We have a
   pointer to the current EC object in the global TLS
   (``PyThreadState`` for CPython.)

3. A set of APIs to work with EC:

   * ``sys.get_execution_context()``: return a shallow copy of
     the current EC object in the global TLS.

   * ``sys.set_execution_context(ec)``: make a shallow copy the passed
     EC object and to set it to the global TLS.

   * ``sys.set_execution_context_value(key, value)``: get the current
     EC and add the passed key/value to it.  If the ``value`` is
     ``None``, the ``key`` will be deleted from the EC object.

   * ``sys.get_execution_context_value(key)``: get the current
     EC object and lookup the ``key`` key on it.  Return ``None``
     if no key was found.

   Note, that some important implementation details and optimizations
   are omitted here, and will be covered in later sections of the PEP.

An important consequence is that any code that is using the above API,
is thread-safe by design.  The rest of this section is focused on
defining the semantics for generators and coroutines within the same
thread.

Before diving into the specification details, let's implement a basic
context manager encapsulating some state using the new APIs.
We will use it in all code examples in this section::

    class Foo:
        def __init__(self, foo):
            self.foo = foo

        def __enter__(self):
            self.old_foo = sys.get_execution_context_value('foo')
            sys.set_execution_context_value('foo', self.foo)

        def __exit__(self, *exc):
            sys.set_execution_context_value('foo', self.old_foo)

    def get_foo():
        return sys.get_execution_context_value('foo')


Regular Code
------------

Regular code will *just* work with the already defined EC semantics::

    with Foo('spam'):
        assert get_foo() == 'spam'

        with Foo('ham'):
            assert get_foo() == 'ham'

        assert get_foo() == 'spam'


Generators
----------


Coroutines
----------


References
==========

.. [1] https://blog.golang.org/context

.. [2] https://msdn.microsoft.com/en-us/library/system.threading.executioncontext.aspx

.. [3] https://github.com/numpy/numpy/issues/9444
